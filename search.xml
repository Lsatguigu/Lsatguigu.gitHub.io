<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git常用命令</title>
    <url>/2022/09/04/10-48-48/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章的环境是在windows环境下编写。</p>
<p>在日常工作中git少不了，所以编写本篇文章教大家如何使用git，便于日后工作与学习。</p>
<p>git命令很多，但是常用的只有十多个。</p>
<span id="more"></span>

<p><a href="#conclusion">命令总结</a></p>
<h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><p>Git最初是由Linux开发者Linus用了仅仅两周时间纯C语言编写而成，在编写完成之后就立马上手接管Linux源代码，不过在此之前Linux是由BitMover公司开发的BitKeeper分布式版本控制系统所管理源代码，它是商业收费的分布式版本控制器，但BitMover公司看中Linux开源精神，免费授权给Linux社区使用，在2002年时，Linux开始使用BitKeeper分布式版本控制系统管理源代码，但好景不长，有一天Linux社区成员Andrew（samba（局域网共享文件c&#x2F;s程序）的作者）试图破解BitKeeper共享给所有人使用，被BitMover公司发现并收回了免费使用的版权，随后Linus就用了两周时间开发出了git(两周时间包括测试)，也就是目前为止最好用的分布式版本控制系统。</p>
<h2 id="集中式与分布式的区别"><a href="#集中式与分布式的区别" class="headerlink" title="集中式与分布式的区别"></a>集中式与分布式的区别</h2><p>除了git还有svn、cvs这样的版本控制系统，它们的区别在于一个是分布式一个是集中式</p>
<p>集中式就是svn和csv这样的版本控制系统，分布式是git</p>
<p>区别在于集中式的版本控制系统每次在写代码时都需要从服务器中拉取一份下来，并且如果服务器丢失了，那么所有的就都丢失了，你本机客户端仅保存当前的版本信息，换句话说，集中式就是把代码放在一个服务器上集中管理，你的所有回滚等操作都需要服务器的支持。</p>
<p>分布式的区别在于，每个人的电脑都是服务器，当你从主仓库拉取一份代码下来后，你的电脑就是服务器，无需担心主仓库被删或者找不到的情况，你可以自由在本地回滚，提交，当你想把自己的代码提交到主仓库时，只需要合并推送到主仓库就可以了，同时你可以把自己的代码新建一份仓库分享给其它人。</p>
<p>像集中式它们都有一个主版本号，所有的版本迭代都以这个版本号为主，而分布式因为每个客户端都是服务器，git没有固定的版本号，但是有一个由哈希算法算出的id，用来回滚用的，同时也有一个master仓库，这个仓库是一切分支仓库的主仓库，我们可以推送提交到master并合并到主仓库上，主仓库的版本号会迭代一次，我们客户端上的git版本号无论迭代多少次，都跟master无关，只有合并时，master才会迭代一次。</p>
<h2 id="Windows安装Git"><a href="#Windows安装Git" class="headerlink" title="Windows安装Git"></a>Windows安装Git</h2><p><a href="https://www.jianshu.com/p/414ccd423efc">Git安装教程（Windows安装超详细教程） - 简书 (jianshu.com)</a></p>
<p>可以参考这位博主，写的很详细了。</p>
<h2 id="配置git环境：git-config-–global"><a href="#配置git环境：git-config-–global" class="headerlink" title="配置git环境：git config –global"></a>配置git环境：git config –global</h2><p>参数讲解：</p>
<blockquote>
<p>config：参数是用来配置git环境的</p>
<p>–global：长命令表示配置整个git环境</p>
</blockquote>
<p>初次使用git需要设置你的用户名以及邮箱，这将作为当前机器git的标识，如果你用它来下载远程仓库一些需要登录权限的仓库会要求登录，git默认使用配置邮箱以及用户名登入，但会要求你手动输入密码</p>
<p>用户名配置</p>
<blockquote>
<p>user代表用户，.name代表配置用户的名称</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br></pre></td></tr></table></figure>

<p>邮箱配置</p>
<blockquote>
<p>user代表用户，.email代表配置用户的邮箱</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>



<h2 id="创建本地空仓库：git-init"><a href="#创建本地空仓库：git-init" class="headerlink" title="创建本地空仓库：git init"></a>创建本地空仓库：git init</h2><blockquote>
<p>init：初始化当前目录为仓库，初始化后会自动将当前仓库设置为master</p>
</blockquote>
<p>创建本地仓库的条件是需要一个空目录，然后在空目录中初始化你的项目</p>
<p>如我想创建一个名为“test”的空项目</p>
<p>1.创建目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>2.进入目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>3.使用git init初始化当前仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h2 id="新建文件添加到本地仓库：git-add、git-commit-m"><a href="#新建文件添加到本地仓库：git-add、git-commit-m" class="headerlink" title="新建文件添加到本地仓库：git add、git commit -m"></a>新建文件添加到本地仓库：git add、git <a href="https://so.csdn.net/so/search?q=commit&spm=1001.2101.3001.7020">commit</a> -m</h2><blockquote>
<p>add：将文件添加到缓存区</p>
<p>commit：提交到本地仓库</p>
</blockquote>
<h2 id="将所有改动文件添加到缓存区：git-add-–all、git-add"><a href="#将所有改动文件添加到缓存区：git-add-–all、git-add" class="headerlink" title="将所有改动文件添加到缓存区：git add –all、git add ."></a>将所有改动文件添加到缓存区：git add –all、git add .</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>



<h2 id="查看历史提交日志：git-log"><a href="#查看历史提交日志：git-log" class="headerlink" title="查看历史提交日志：git log"></a>查看历史提交日志：git log</h2><blockquote>
<p>log：查看日志</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<h2 id="回滚代码仓库：git-reset-–hard"><a href="#回滚代码仓库：git-reset-–hard" class="headerlink" title="回滚代码仓库：git reset –hard"></a>回滚代码仓库：git <a href="https://so.csdn.net/so/search?q=reset&spm=1001.2101.3001.7020">reset</a> –hard</h2><p>reset参数是重置命令</p>
<p>–hard是重置代码仓库版本</p>
<p>1.回滚到指定历史版本</p>
<p>先使用git log查看历史版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>在使用git reset –hard命令回滚</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 要回滚<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>2.回滚当前仓库指向的版本</p>
<p>HEAD是指向当前仓库的，历史版本中可能有别的分支，我们只想迭代我们仓库的上一个版本，这个很简单，我们只需要用HEAD来指向就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>^代表上一个版本的意思，HEAD代表当前仓库的指向，当前HEAD指向master，就代表回滚到master上一次提交的版本</p>
<p>当然我们也可以使用另外一种方式来回滚到当前仓库的指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD~3</span><br></pre></td></tr></table></figure>

<p>后面的~ 3，代表以当前版本为基数，回滚多少次。HEAD~3代表回滚master前三个版本</p>
<p>如果觉得log打印内容过多，可以加上–pretty&#x3D;oneline选项简洁输出</p>
<h2 id="查看提交之后文件是否做了改动：git-status"><a href="#查看提交之后文件是否做了改动：git-status" class="headerlink" title="查看提交之后文件是否做了改动：git status"></a>查看提交之后文件是否做了改动：git status</h2><blockquote>
<p>status：查看当前仓库状态</p>
</blockquote>
<p>我们在提交完成之后，有时候可能自己不小心改动了某个文件，或者别人，我们可以使用git status查看文件是否被改动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<h2 id="工作区与缓存区"><a href="#工作区与缓存区" class="headerlink" title="工作区与缓存区"></a>工作区与缓存区</h2><p>在git下有一个概念是缓存区，这是其它集中式版本控制系统没有的</p>
<p>工作区：工作区就是你当前的工作目录</p>
<p>缓存区：这里存放了你使用git add命令提交的文件描述信息，它位于.git目录下的index文件中</p>
<h2 id="删除文件：git-rm"><a href="#删除文件：git-rm" class="headerlink" title="删除文件：git rm"></a>删除文件：git rm</h2><p>如果我们使用普通的命令，rm删除文件，git状态会提示你删除了文件，你只需要使用add重新提交一次就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> X</span><br></pre></td></tr></table></figure>

<h2 id="查看提交历史：git-reflog"><a href="#查看提交历史：git-reflog" class="headerlink" title="查看提交历史：git reflog"></a>查看提交历史：git reflog</h2><p>git reflog可以查看当前版本库的提交历史，凡是对仓库版本进行迭代的都会出现在这个里面，包括你回滚版本都会出现在这个历史中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>



<h2 id="git创建分支：git-branch、git-checkout"><a href="#git创建分支：git-branch、git-checkout" class="headerlink" title="git创建分支：git branch、git checkout"></a>git创建分支：git branch、git checkout</h2><p>使用git checkout -b参数来创建一个分支，创建完成分支后会自动切换过去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure>

<p>然后我们在使用branch来查看当前属于哪个分支，也就是查看HEAD的指向</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>git checkout -b等价于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>

<p>git branch 如果后面跟着名字则会创建分支，但不会切换</p>
<p>git checkout 后面如果是分支名称则切换过去</p>
<h2 id="git切换分支：git-checkout"><a href="#git切换分支：git-checkout" class="headerlink" title="git切换分支：git checkout"></a>git切换分支：git checkout</h2><p>当我们想切换分支可以使用git checkout来切换，如刚刚我们创建了一个分支dev并切换了过去，现在切换回masterk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>git checkout的作用是检出，如果是文件的话，会放弃对文件的缓存区操作，但是要使用reset重置一下变更才行。</p>
<p>如果是分支的话会切换过去。</p>
<h2 id="git合并分支：git-merge"><a href="#git合并分支：git-merge" class="headerlink" title="git合并分支：git merge"></a>git合并分支：git merge</h2><p>当我们新建分支并做完工作之后，想要把分支提交至master，只需要切换到master仓库，并执行git merge 分支名就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>

<h2 id="git查看分支：git-branch-a"><a href="#git查看分支：git-branch-a" class="headerlink" title="git查看分支：git branch -a"></a>git查看分支：git branch -a</h2><p>如果要查看当前所有分支可以使用：git branch -a</p>
<p>HEAD指向当前分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<h2 id="git删除本地分支：git-branch-D"><a href="#git删除本地分支：git-branch-D" class="headerlink" title="git删除本地分支：git branch -D"></a>git删除本地分支：git branch -D</h2><p>git branch -D 分支名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D 分支名</span><br></pre></td></tr></table></figure>

<h2 id="git删除远程分支：git-push-origin-–delete"><a href="#git删除远程分支：git-push-origin-–delete" class="headerlink" title="git删除远程分支：git push origin –delete"></a>git删除远程分支：git push origin –delete</h2><p>注意这里的远程分支名不需要加origin，输入分支名就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete 远程分支名</span><br></pre></td></tr></table></figure>

<h2 id="gitee的使用"><a href="#gitee的使用" class="headerlink" title="gitee的使用"></a>gitee的使用</h2><p>1.首先到gitee上注册一个你的账号</p>
<p>2.在本地创建一个ssh的key，因为gitee是使用ssh服务进行通讯的</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>它会要求输入Enter file in which to save the key (&#x2F;home&#x2F;stephenzhou&#x2F;.ssh&#x2F;id_rsa)</p>
<p>这里是生成的sshkey文件名，我们可以回车使用默认文件名</p>
<p>除此之外还会让你输入</p>
<p>Created directory ‘&#x2F;home&#x2F;stephenzhou&#x2F;.ssh’.<br>Enter passphrase (empty for no passphrase):<br>这个密码会在让你push提交时候要输入的，除了git登录密码，还要输入这个密码，直接回车则空密码，这里我们直接回车</p>
<p>接着会让你在此输入密码，验证这里依旧回车</p>
<p>Enter same passphrase again：</p>
<p>生成之后你就会看到这样的界面:</p>
<p><img src="/2022/09/04/10-48-48/image-20220904125734139.png" alt="image-20220904125734139"></p>
<p>生成的ssh文件如果不使用-f指定的话会生成在用户目录下的.ssh目录中，.ssh是隐藏文件，可以使用ls -ah看到，使用cd ~进入用户主目录，然后cd进入到.ssh目录中可以看到文件</p>
<p><img src="/2022/09/04/10-48-48/image-20220904130103886.png" alt="image-20220904130103886"></p>
<p>打开id_rsa.pub文件、全选、复制</p>
<p>id_rsa是私匙，id_rsa.pub是公匙，id_rsa不能告诉任何人，只有公钥可以，ssh采用的是非对称加密。</p>
<p>接着在gitee上添加你的公钥</p>
<p><img src="/2022/09/04/10-48-48/image-20220904130350701.png" alt="image-20220904130350701"></p>
<p><img src="/2022/09/04/10-48-48/image-20220904130452511.png" alt="image-20220904130452511"></p>
<p>最后在输入你的gitee登录密码就可以了</p>
<h2 id="gitee将本地仓库关联到远程仓库：git-remote-add-origin"><a href="#gitee将本地仓库关联到远程仓库：git-remote-add-origin" class="headerlink" title="gitee将本地仓库关联到远程仓库：git remote add origin"></a>gitee将本地仓库关联到远程仓库：git remote add origin</h2><p>我们本地有一个仓库，我们想把它推送到远程上去，很简单，我们只需要使用git remote add origin命令就可以了，ongin是gitee上的仓库名称，意思是远程仓库的意思。</p>
<p>首先选择仓库的code找到gitee生成的远程仓库链接</p>
<p><img src="/2022/09/04/10-48-48/image-20220904130711504.png" alt="image-20220904130711504"></p>
<p>然后关联</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:beiszhihao/test.git</span><br></pre></td></tr></table></figure>

<p>然后使用git push推送到远程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="git将远程仓库关联到本地和拉取指定分支、切换远程分支：git-clone"><a href="#git将远程仓库关联到本地和拉取指定分支、切换远程分支：git-clone" class="headerlink" title="git将远程仓库关联到本地和拉取指定分支、切换远程分支：git clone"></a>git将远程仓库关联到本地和拉取指定分支、切换远程分支：git clone</h2><p>当我们远程有仓库时，想要关联到本地只需要使用git clone就可以了</p>
<p>新建一个空目录，不要git init</p>
<p>使用git clone会自动帮我们初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitee.com:beiszhihao/test.git</span><br></pre></td></tr></table></figure>

<h2 id="gitee提交本地仓库到远程仓库：git-add、git-commit、git-push"><a href="#gitee提交本地仓库到远程仓库：git-add、git-commit、git-push" class="headerlink" title="gitee提交本地仓库到远程仓库：git add、git commit、git push"></a>gitee提交本地仓库到远程仓库：git add、git commit、git push</h2><p>使用git add提交到缓存区，在使用commit提交到本地仓库，在使用push推送到远程就可以了，非常简单，命令都是我们学过的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add XX</span><br><span class="line">git commit -m <span class="string">&quot;XX&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="git命令总结"><a href="#git命令总结" class="headerlink" title="git命令总结"></a><div id="conclusion">git命令总结<div></div></div></h2>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>：         XX (创建一个空目录 XX指目录名)</span><br><span class="line">   </span><br><span class="line">git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</span><br><span class="line">   </span><br><span class="line">git add XX       把xx文件添加到暂存区去。</span><br><span class="line">   </span><br><span class="line">git commit –m “XX”  提交文件 –m 后面的是注释。</span><br><span class="line">   </span><br><span class="line">git status        查看仓库状态</span><br><span class="line">   </span><br><span class="line">git <span class="built_in">log</span>          查看历史记录</span><br><span class="line">   </span><br><span class="line">git reset  --hard HEAD^ 或者 git reset  --hard HEAD~ 回退到上一个版本</span><br><span class="line">(如果想回退到100个版本，使用git reset –hard HEAD~100 )</span><br><span class="line">   </span><br><span class="line">git reflog       查看历史记录的版本号<span class="built_in">id</span></span><br><span class="line">   </span><br><span class="line">git checkout -- XX  把XX文件在工作区的修改全部撤销。</span><br><span class="line">   </span><br><span class="line">git <span class="built_in">rm</span> XX          删除XX文件</span><br><span class="line">   </span><br><span class="line">git remote add origin https://gitee.com/tugenhua0707/testgit 关联一个远程库</span><br><span class="line">   </span><br><span class="line">git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</span><br><span class="line">   </span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/tugenhua0707/testgit  从远程库中克隆</span><br><span class="line">   </span><br><span class="line">git checkout –b dev  创建dev分支 并切换到dev分支上</span><br><span class="line">   </span><br><span class="line">git branch  查看当前所有的分支</span><br><span class="line">   </span><br><span class="line">git checkout master 切换回master分支</span><br><span class="line">   </span><br><span class="line">git branch –d dev 删除dev分支</span><br><span class="line">   </span><br><span class="line">git branch name  创建分支</span><br><span class="line">   </span><br><span class="line">git remote 查看远程库的信息</span><br><span class="line">   </span><br><span class="line">git remote –v 查看远程库的详细信息</span><br><span class="line">   </span><br><span class="line">git push origin master  Git会把master分支推送到远程库对应的远程分支上</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitee</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC总复习</title>
    <url>/2022/09/11/09-20-48/</url>
    <content><![CDATA[<h2 id="第一章-JDBC概述"><a href="#第一章-JDBC概述" class="headerlink" title="第一章 JDBC概述"></a>第一章 JDBC概述</h2><h3 id="1-jdbc的概念"><a href="#1-jdbc的概念" class="headerlink" title="1.jdbc的概念"></a>1.jdbc的概念</h3><p>JDBC（Java DataBase Connectivity：java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。<br>JDBC的作用：可以通过java代码操作数据库</p>
<span id="more"></span>

<h3 id="2-jdbc的本质"><a href="#2-jdbc的本质" class="headerlink" title="2.jdbc的本质"></a>2.jdbc的本质</h3><p>其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！</p>
<h3 id="2-面向接口编程的思想"><a href="#2-面向接口编程的思想" class="headerlink" title="2.面向接口编程的思想"></a>2.面向接口编程的思想</h3><ol>
<li>JDBC 是 sun 公司提供一套用于数据库操作的接口，java 程序员只需要面向这套接口编程即可。</li>
<li>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</li>
</ol>
<h2 id="第二章-数据库的连接"><a href="#第二章-数据库的连接" class="headerlink" title="第二章 数据库的连接"></a>第二章 数据库的连接</h2><h3 id="1、数据库连接的一般步骤"><a href="#1、数据库连接的一般步骤" class="headerlink" title="1、数据库连接的一般步骤"></a>1、数据库连接的一般步骤</h3><ol>
<li>配置连接的基本信息：url、user、password</li>
<li>加载驱动：其实分为新建驱动、注册驱动和加载驱动三步，但是一般直接加载驱动，java 会自动的新建驱动和注册驱动（见下方代码，其中提供了静态代码块，来实现这两部分操作）</li>
<li>获得连接</li>
</ol>
<h3 id="2、数据库连接代码示例（MySQL）"><a href="#2、数据库连接代码示例（MySQL）" class="headerlink" title="2、数据库连接代码示例（MySQL）"></a>2、数据库连接代码示例（MySQL）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.读取配置文件中的4个基本信息</span></span><br><span class="line">        <span class="comment">// 当前类.class.获取类加载器.获取输入流的文件名</span></span><br><span class="line">		<span class="comment">// 自定义类是由系统类加载器加载的</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意！！！</strong>：</p>
<ul>
<li>用 I&#x2F;O 流的方式来获取配置文件</li>
<li>用系统类加载器来加载自定义类</li>
</ul>
<p>其中，配置文件【<strong>jdbc.properties</strong>】：此配置文件声明在工程的src下（下面为 MySQL 8.0 版本的配置信息）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br><span class="line">user=root</span><br><span class="line">password=<span class="number">7421279</span></span><br><span class="line">driverClass=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用配置文件的好处：</p>
<ul>
<li>实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 ；</li>
<li>如果修改了配置信息，省去重新编译的过程，代码效率更高。</li>
</ul>
<h3 id="3、JDBCUtils（操作数据库的工具类）"><a href="#3、JDBCUtils（操作数据库的工具类）" class="headerlink" title="3、JDBCUtils（操作数据库的工具类）"></a>3、JDBCUtils（操作数据库的工具类）</h3><p>每一次与数据库交互都要进行连接，关闭资源等，所以将其封装成工具类，使用时直接调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu3.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.读取配置文件中的4个基本信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.加载驱动</span></span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeResource</span><span class="params">(Connection conn, Statement ps)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>)</span><br><span class="line">                ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeResource</span><span class="params">(Connection conn, Statement ps, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>)</span><br><span class="line">                ps.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>)</span><br><span class="line">                rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第三章：使用-PreparedStatement-实现-CRUD-操作"><a href="#第三章：使用-PreparedStatement-实现-CRUD-操作" class="headerlink" title="第三章：使用 PreparedStatement 实现 CRUD 操作"></a>第三章：使用 PreparedStatement 实现 CRUD 操作</h2><h3 id="1、Statement-使用的弊端"><a href="#1、Statement-使用的弊端" class="headerlink" title="1、Statement 使用的弊端"></a>1、Statement 使用的弊端</h3><ol>
<li>存在拼串操作，繁琐</li>
<li>存在 SQL 注入问题</li>
<li>没办法操作Blob类型变量</li>
<li>实现批量插入时，效率较低</li>
</ol>
<p>问题一（拼串操作）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Scanner scan = new Scanner(System.<span class="keyword">in</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">String userName = scan.next();</span><br><span class="line">System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">String password = scan.next();</span><br><span class="line"></span><br><span class="line">// SELECT user,password FROM user_table WHERE USER = <span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27; AND PASSWORD = &#x27;</span> =<span class="string">&#x27;1&#x27;</span> or <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">String sql = <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题二（SQL注入）:</p>
<p>恶意拼接查询</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users <span class="type">WHERE</span> <span class="variable">user_id</span> <span class="operator">=</span> $user_id</span><br></pre></td></tr></table></figure>

<p>其中，user_id 是传入的参数，如果传入的参数值为“1234; DELETE FROM users”，那么最终的查询语句会变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users <span class="type">WHERE</span> <span class="variable">user_id</span> <span class="operator">=</span> <span class="number">1234</span>; DELETE FROM users</span><br></pre></td></tr></table></figure>

<p>如果以上语句执行，则会删除 users 表中的所有数据。</p>
<h3 id="2、PreparedStatement-替换-Statement-实现-CRUD-操作"><a href="#2、PreparedStatement-替换-Statement-实现-CRUD-操作" class="headerlink" title="2、PreparedStatement 替换 Statement 实现 CRUD 操作"></a>2、PreparedStatement 替换 Statement 实现 CRUD 操作</h3><p>PreparedStatement的理解：<br>① PreparedStatement 是 Statement 的子接口<br>② An object that represents a precompiled SQL statement. （预编译 SQL 语句，只需要填空即可）<br>③ 可以解决Statement的sql注入问题，拼串问题</p>
<h3 id="3、使用-PreparedStatement-实现通用的查询操作"><a href="#3、使用-PreparedStatement-实现通用的查询操作" class="headerlink" title="3、使用 PreparedStatement 实现通用的查询操作"></a>3、使用 PreparedStatement 实现通用的查询操作</h3><ol>
<li>获取与数据库的连接 Connection</li>
<li>预编译 sql 语句，返回 PreparedStatement 的实例</li>
<li>填充占位符</li>
<li>执行此 PreparedStatement 对象中的 SQL 查询语句，并返回一个结果集 ResultSet</li>
<li>通过 ResultSet 得到结果集的元数据：ResultSetMetaData</li>
<li>通过 ResultSetMetaData 得到 数据集列数 columnCount，数据列别名 columnLabel；通过 ResultSet 得到列值；使用反射，给对象的相应属性赋值，给t对象指定的 columnLabel 属性，赋值为 columValue</li>
<li>关闭 Connection，PreparedStatement，ResultSet 资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集的元数据 :ResultSetMetaData</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">// 通过ResultSetMetaData获取结果集中的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="comment">// 处理结果集一行数据中的每一个列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    <span class="comment">// 获取列值</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columValue</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取每个列的列名</span></span><br><span class="line">                    <span class="comment">// String columnName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 给t对象指定的columnName属性，赋值为columValue：通过反射</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, columValue);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getForList</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">// 获取结果集的元数据 :ResultSetMetaData</span></span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="comment">// 通过ResultSetMetaData获取结果集中的列数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//创建集合对象</span></span><br><span class="line">            ArrayList&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">                <span class="comment">// 处理结果集一行数据中的每一个列:给t对象指定的属性赋值</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">                    <span class="comment">// 获取列值</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">columValue</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取每个列的列名</span></span><br><span class="line">                    <span class="comment">// String columnName = rsmd.getColumnName(i + 1);</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 给t对象指定的columnName属性，赋值为columValue：通过反射</span></span><br><span class="line">                    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    field.set(t, columValue);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);<span class="comment">//对于查询到的多条数据来说，把每一个对象放进集合里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>两种思想：</strong><br>（1）面向接口编程的思想<br>（2）<strong>ORM 编程思想</strong>：（object relational mapping），有点万事万物皆对象那种意思</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
<p><strong>两种技术：</strong></p>
<p>（1）使用结果集的元数据：ResultSetMetaData</p>
<blockquote>
<p>getColumnCount()：获取列数</p>
<p>getColumnLabel()：获取列的别名<br>说明：如果 sql 中没给字段其别名，getColumnLabel()获取的就是列名</p>
</blockquote>
<p>（2）反射的使用</p>
<blockquote>
<p>创建对应的<strong>运行时类的对象</strong><br>在运行时，动态的调用指定的<strong>运行时类的属性、方法</strong></p>
</blockquote>
<h2 id="4、PreparedStatement-与-Statement-的异同"><a href="#4、PreparedStatement-与-Statement-的异同" class="headerlink" title="4、PreparedStatement 与 Statement 的异同"></a>4、PreparedStatement 与 Statement 的异同</h2><p>①PreparedStatement 是Statement的子类</p>
<p>②Statement 存在SQL注入问题，实际开发中选用PreparedStatement替换Statement</p>
<p>③PreparedStatement是预编译SQL语句，用占位符其可读性高，安全性高</p>
<p>④PreparedStatement<strong>预编译</strong>可以提供优化，在被DBServer编译后会缓存下来，从而在处理大量数据时的速度也会更快</p>
<h2 id="第四章-数据库事务"><a href="#第四章-数据库事务" class="headerlink" title="第四章 数据库事务"></a>第四章 数据库事务</h2><h3 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h3><ol>
<li>一组逻辑操作单元,使数据从一种状态变换到另一种状态。</li>
<li>一组逻辑操作单元：一个或多个DML操作。</li>
</ol>
<h3 id="2、事务处理的原则（提交or回滚）"><a href="#2、事务处理的原则（提交or回滚）" class="headerlink" title="2、事务处理的原则（提交or回滚）"></a>2、事务处理的原则（提交or回滚）</h3><p>保证所事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。<br>当在一个事务中执行多个操作时，<strong>要么所有的事务都被提交(commit)<strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，</strong>整个事务回滚(rollback)到最初状态。</strong></p>
<p>说明：<br>1.数据一旦提交，就不可回滚<br>2.哪些操作会导致数据的自动提交？</p>
<p>DDL操作一旦执行，都会自动提交。</p>
<blockquote>
<ul>
<li>set autocommit &#x3D; false 对 DDL 操作失效</li>
<li>DML默认情况下，一旦执行，就会自动提交。</li>
<li>我们可以通过 set autocommit &#x3D; false 的方式取消 DML 操作的自动提交。</li>
<li>默认在关闭连接时，会自动的提交数据</li>
</ul>
</blockquote>
<h2 id="3、事务的-ACID-属性"><a href="#3、事务的-ACID-属性" class="headerlink" title="3、事务的 ACID 属性"></a>3、事务的 ACID 属性</h2><ol>
<li><strong>原子性（Atomicity）</strong>： 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>
<li><strong>一致性（Consistency）</strong> ：事务必须使数据库从一个<strong>一致性状态</strong>变换到另外一个一致性状态。</li>
<li>隔离性（Isolation） ：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，<strong>并发执行的各个事务之间不能互相干扰。</strong></li>
<li>持久性（Durability） ：持久性是指一个<strong>事务一旦被提交</strong>，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li>
</ol>
<h3 id="3-1-数据库的并发问题"><a href="#3-1-数据库的并发问题" class="headerlink" title="3.1 数据库的并发问题"></a>3.1 数据库的并发问题</h3><h4 id="1-脏读（dirty-read）"><a href="#1-脏读（dirty-read）" class="headerlink" title="1.脏读（dirty read）"></a>1.脏读（dirty read）</h4><p> A事务读取了B事务尚未提交的更改数据，并且在这个数据基础上进行操作。如果此时恰巧B事务进行回滚，那么A事务读到的数据是根本不被承认的。</p>
<h4 id="2-不可重复读（unrepeatable-read）"><a href="#2-不可重复读（unrepeatable-read）" class="headerlink" title="2.不可重复读（unrepeatable read）"></a>2.不可重复读（unrepeatable read）</h4><p> 不可重复读是指A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额发生不一致</p>
<h4 id="3-幻读（phantom-read）"><a href="#3-幻读（phantom-read）" class="headerlink" title="3.幻读（phantom read）"></a>3.幻读（phantom read）</h4><p> A事务读取B提交的新增数据，这时A事务将出现幻想读的问题。幻读一般发生在计算统计数据的事务中。举个例子，假设银行系统在同一个事务中两次统计存款的总金额，在两次统计过程中，刚好新增了一个存款账户，并存入100元，这时两次统计的总金额将不一致。</p>
<h2 id="第四章-数据库连接池"><a href="#第四章-数据库连接池" class="headerlink" title="第四章 数据库连接池"></a>第四章 数据库连接池</h2><h3 id="1、什么是连接池"><a href="#1、什么是连接池" class="headerlink" title="1、什么是连接池"></a>1、什么是连接池</h3><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。</p>
<h3 id="2、使用数据库连接池的好处"><a href="#2、使用数据库连接池的好处" class="headerlink" title="2、使用数据库连接池的好处"></a>2、使用数据库连接池的好处</h3><ol>
<li>提高程序的响应速度(减少了创建连接相应的时间)</li>
<li>降低资源的消耗(可以重复使用已经提供好的连接)</li>
<li>便于连接的管理，可以设置最大数据库连接数量、最大连接活跃数等等</li>
</ol>
<h3 id="3、实现的方式（推荐使用Druid）"><a href="#3、实现的方式（推荐使用Druid）" class="headerlink" title="3、实现的方式（推荐使用Druid）"></a>3、实现的方式（推荐使用Druid）</h3><p><strong>JDBC</strong>的数据库连接池使用javax.sql.DataSource来表示,DataSource只是一个接口,该接口通常由服务器(Weblogic,WwebSphere,Tomcat)提供实现,也有一些开源组织提供实现:</p>
<ul>
<li>DBCP</li>
<li>C3P0</li>
<li>Proxool</li>
<li>BoneCP</li>
<li><strong>Druid</strong></li>
</ul>
<h3 id="4、如何使用数据库连接池（以Druid为例）"><a href="#4、如何使用数据库连接池（以Druid为例）" class="headerlink" title="4、如何使用数据库连接池（以Druid为例）"></a>4、如何使用数据库连接池（以Druid为例）</h3><ol>
<li>导入jar包：</li>
<li>测试连接的代码：<br>（1）加载配置文件<br>（2）获取数据库连接池中的连接<br>（3）与数据库建立连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">	pros.load(is);</span><br><span class="line">	</span><br><span class="line">	<span class="type">DataSource</span> <span class="variable">source</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line">	System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>封装成 JDBCUtils 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Druid数据库连接池技术</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source1;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">		pros.load(is);</span><br><span class="line">		source1 = DruidDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source1.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 每次加载类的收只用创建一个 Druid 数据库连接池，这里使用静态代码块来实现。</p>
<p>3.配置文件定义在 src 下：druid.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">///test</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">7421279</span></span><br><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第五章-DBUtils-提供的-jar-包实现-CRUD-操作"><a href="#第五章-DBUtils-提供的-jar-包实现-CRUD-操作" class="headerlink" title="第五章 DBUtils 提供的 jar 包实现 CRUD 操作"></a>第五章 DBUtils 提供的 jar 包实现 CRUD 操作</h2><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库,封装了针对于数据库的增删改查操作</p>
<p>1、导入jar包：</p>
<p>2、使用现成的 jar 中的 QueryRunner 测试增、删、改的操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试插入</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth)values(?,?,?)&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertCount</span> <span class="operator">=</span> runner.update(conn, sql, <span class="string">&quot;蔡徐坤&quot;</span>,<span class="string">&quot;caixukun@126.com&quot;</span>,<span class="string">&quot;1997-09-08&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;添加了&quot;</span> + insertCount + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、使用现成的 jar 中的 QueryRunner 测试查询的操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试查询</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BeanHander:是ResultSetHandler接口的实现类，用于封装表中的一条记录，表中的记录封装完之后返回一个对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery1</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">		BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">		<span class="comment">//ResultSetHandler（接口）是结果集的一个处理器，有多种实现类，其中BeanHandler是通用的</span></span><br><span class="line">		<span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler, <span class="number">26</span>);</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * BeanListHandler:是ResultSetHandler接口的实现类，用于封装表中的多条记录构成的集合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		BeanListHandler&lt;Customer&gt;  handler = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Customer.class);</span><br><span class="line">		List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		list.forEach(System.out::println);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MapHander:是ResultSetHandler接口的实现类，对应表中的一条记录。</span></span><br><span class="line"><span class="comment"> * 将字段及相应字段的值作为map中的key和value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery3</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		<span class="type">MapHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapHandler</span>();</span><br><span class="line">		Map&lt;String, Object&gt; map = runner.query(conn, sql, handler, <span class="number">26</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MapListHander:是ResultSetHandler接口的实现类，对应表中的多条记录。</span></span><br><span class="line"><span class="comment"> * 将字段及相应字段的值作为map中的key和value。将这些map添加到List中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery4</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id &lt; ?&quot;</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="type">MapListHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapListHandler</span>();</span><br><span class="line">		List&lt;Map&lt;String, Object&gt;&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">		list.forEach(System.out::println);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ScalarHandler:用于查询特殊值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery5</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from customers&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line">		<span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> (Long) runner.query(conn, sql, handler);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery6</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select max(birth) from customers&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">ScalarHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>();</span><br><span class="line">		<span class="type">Date</span> <span class="variable">maxBirth</span> <span class="operator">=</span> (Date) runner.query(conn, sql, handler);</span><br><span class="line">		System.out.println(maxBirth);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery7</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">		conn = JDBCUtils.getConnection3();</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,email,birth from customers where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">//提供一个handler的匿名实现类</span></span><br><span class="line">		ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> <span class="title class_">ResultSetHandler</span>&lt;Customer&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Customer <span class="title function_">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="comment">//					System.out.println(&quot;handle&quot;);</span></span><br><span class="line"><span class="comment">//					return null;</span></span><br><span class="line"><span class="comment">//					return new Customer(12, &quot;成龙&quot;, &quot;Jacky@126.com&quot;, new Date(234324234324L));</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">					<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">					<span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">					<span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;birth&quot;</span>);</span><br><span class="line">					<span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">					<span class="keyword">return</span> customer;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//handler中最后返回的对象就是这里query最终的返回对象</span></span><br><span class="line">		<span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> runner.query(conn, sql, handler,<span class="number">26</span>);</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、使用 dbutils.jar 包中的 DbUtils 工具类实现连接等资源的关闭：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeResource1</span><span class="params">(Connection conn,Statement ps,ResultSet rs)</span>&#123;</span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			DbUtils.close(conn);</span></span><br><span class="line"><span class="comment">//		&#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			DbUtils.close(ps);</span></span><br><span class="line"><span class="comment">//		&#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			DbUtils.close(rs);</span></span><br><span class="line"><span class="comment">//		&#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"></span><br><span class="line">	DbUtils.closeQuietly(conn);</span><br><span class="line">	DbUtils.closeQuietly(ps);</span><br><span class="line">	DbUtils.closeQuietly(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
